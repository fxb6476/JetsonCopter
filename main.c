// Created by heapr0ll on 7/7/19.
//

#include "Lib/JHPWMPCA9685.h"
#include "Lib/i2c_bno055.h"
#include <ncurses.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <iostream>
#include <ctype.h>
#include <unistd.h>
#include <string.h>
#include <getopt.h>
#include <time.h>
#include <sys/time.h>
#include <chrono>

using namespace std;

// At 50 hz a frame is 20 milliseconds
// The PCA9685 PWM Driver is 12 bits
// Full Reverse signal to the ESC is 1 ms
// Neutral signal to the ESC is 1.5 ms
// Full Throttle signal to the ESC is 2 ms

int THROTTLE_OFF = 1638;
int THROTTLE_MEDIUM = 2457;
int THROTTLE_FULL = 3276;
int HOOVER = 2215;

int rate = 12000;

// The ESC is plugged into the following PWM channel
int ESC_FL = 0;
int ESC_FR = 1;
int ESC_BL = 2;
int ESC_BR = 3;

// Defining desired pitch roll and yaw angles.
float PITCH = 0;
float ROLL = 0;
float YAW = 0;

// Pitch - PID, Roll - PID, Yaw - PD
float pitch_gains[3] = {1.0, 0.0, 50.0};
float roll_gains[3] =  {1.0, 0.0, 50.0};
float yaw_gains[2] =   {1.0, .01};

// Variables for controller.
float delta_t = 0.0;
float old_error[3] =   {0.0, 0.0, 0.0};
float total_error[2] = {0.0, 0.0};
float new_err[3];
int adjustments[3] = {0,0,0};
int new_speeds[4] = {0, 0, 0, 0};

// Global variables for bno055
opmode_t newmode = ndof_fmc;
char sendaddr[5] = "0x28";
char calfile[21] = "../cal_files/bno.cfg";

// PCA Variables
PCA9685 *pca9685;

bool run = true;

char input;

void catchC(int sig){
    run = false;
}


int main() {

    //  Using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
    //  Or, you can create the .ini in some other directory by using:
    //      RTIMUSettings *settings = new RTIMUSettings("<directory path>", "RTIMULib");
    //  where <directory path> is the path to where the .ini file is to be loaded/saved
    initscr();
    nodelay(stdscr, true);
    noecho();
    //raw();

    // Initialize the BNO055.
    // Checking if the sensor is actually connected and on the write address. (If fails program exits)
    get_i2cbus(sendaddr);

    // Loading cal file into bno. (I think this will exit if it doesnt happen correctly.)
    load_cal(calfile);

    // Put bno into fast fusion mode. (Obviously exits if failes lol)
    int res = set_mode(newmode);
    if(res != 0) {
        printw("Error: could not set sensor mode [0x%02X].\n", newmode);
        exit(-1);
    }

    // BNO initialization finished. Ready to start reading it.
    // Going to double check if we are in fusion mode.
    int mode = get_mode();
    if(mode < 8){
        printw("Error - Not in fusion mode, in %d mode.\n", mode);
        exit(-1);
    }

    printw("BNO ready to work!\n");
    delta_t = (float)rate/1000000.0;

    printw("Sampling the imu at: %d\n", rate);

    pca9685 = new PCA9685() ;
    int err = pca9685->openPCA9685();
    if (err < 0){
        printw("Error: %d", pca9685->error);
    }
    printw("PCA9685 Device Address: 0x%02X\n",pca9685->kI2CAddress) ;
    pca9685->setAllPWM(0,0) ;
    pca9685->reset() ;
    pca9685->setPWMFrequency(400) ;

    pca9685->setPWM(ESC_FL,0,THROTTLE_OFF);
    pca9685->setPWM(ESC_FR,0,THROTTLE_OFF);
    pca9685->setPWM(ESC_BL,0,THROTTLE_OFF);
    pca9685->setPWM(ESC_BR,0,THROTTLE_OFF);

    printw("PCA9685 ready to work!\n");
    refresh();

    sleep(5);

    float angles[3];
    signal(SIGINT, catchC);

    while (run) {
        // To make it even more robust timing wise, check system time before if statement,
        // then check system time after if, find out time left until 13 milliseconds have passed,
        // then wait for that amount of time.
        auto start = chrono::steady_clock::now();

        input = getch();
        if (input == '\33'){
            getch();
            input = getch();
            if (input == 'A'){
                HOOVER++;
            }
            if (input == 'B'){
                HOOVER--;
            }
        }else if(input == 'e'){
            break;
        }

        // Reading the BNO.
        struct bnoeul bnod;
        res = get_eul(&bnod);
        if(res != 0){
            printw("Error: Could not read Euler orientation data.\n");
            break;
        }

        // Controller code.
        angles[0] = bnod.eul_pitc;
        angles[1] = bnod.eul_roll;
        angles[2] = bnod.eul_head;
        new_err[0] = PITCH - angles[0];
        new_err[1] = ROLL - angles[1];
        new_err[2] = YAW - angles[2];
        total_error[0] += pitch_gains[1] * new_err[0];
        total_error[1] += roll_gains[1] * new_err[1];
        adjustments[0] = (int)(pitch_gains[0]*new_err[0] + total_error[0] + pitch_gains[2]*(new_err[0]-old_error[0]) );
        adjustments[1] = (int)(roll_gains[0]*new_err[1] + total_error[1] + roll_gains[2]*(new_err[1]-old_error[1]) );
        adjustments[2] = (int)(yaw_gains[0]*new_err[2] + yaw_gains[1]*((new_err[2]-old_error[2])/delta_t) );

        // Update errors such that old becomes new.
        old_error[0] = new_err[0];
        old_error[1] = new_err[1];
        old_error[2] = new_err[2];

        // Keeping Yaw out of this for now lol. It is because yaw works with a magnometer
        // which will most likely require calibration after flying for a few seconds.
        new_speeds[0] = HOOVER + adjustments[0] + adjustments[1];
        new_speeds[1] = HOOVER + adjustments[0] - adjustments[1];
        new_speeds[2] = HOOVER - adjustments[0] + adjustments[1];
        new_speeds[3] = HOOVER - adjustments[0] - adjustments[1];

        (new_speeds[0] < THROTTLE_OFF) ?  (new_speeds[0] = THROTTLE_OFF) : new_speeds[0];
        (new_speeds[0] > THROTTLE_FULL) ? (new_speeds[0] = THROTTLE_FULL): new_speeds[0];
        (new_speeds[1] < THROTTLE_OFF) ?  (new_speeds[1] = THROTTLE_OFF) : new_speeds[1];
        (new_speeds[1] > THROTTLE_FULL) ? (new_speeds[1] = THROTTLE_FULL): new_speeds[1];
        (new_speeds[2] < THROTTLE_OFF) ?  (new_speeds[2] = THROTTLE_OFF) : new_speeds[2];
        (new_speeds[2] > THROTTLE_FULL) ? (new_speeds[2] = THROTTLE_FULL): new_speeds[2];
        (new_speeds[3] < THROTTLE_OFF) ?  (new_speeds[3] = THROTTLE_OFF) : new_speeds[3];
        (new_speeds[3] > THROTTLE_FULL) ? (new_speeds[3] = THROTTLE_FULL): new_speeds[3];

        //printw("Values %d, %d, %d, %d\n", new_speeds[0], new_speeds[1], new_speeds[2], new_speeds[3]);

    	pca9685->setPWM(ESC_FL,0,new_speeds[0]);
    	pca9685->setPWM(ESC_FR,0,new_speeds[1]);
    	pca9685->setPWM(ESC_BL,0,new_speeds[2]);
    	pca9685->setPWM(ESC_BR,0,new_speeds[3]);

        auto end = chrono::steady_clock::now();
        int elapsed = chrono::duration_cast<chrono::microseconds>(end - start).count();
        //printw("Elapsed Time micro-seconds: %d\n", elapsed);
        if ((rate - elapsed) < 0) {
            //printw("Oops! Something took to long.\n");
            continue;
        }
        usleep(rate - elapsed);
        refresh();
        //auto end2 = chrono::steady_clock::now();
        //elapsed = chrono::duration_cast<chrono::microseconds>(end2 - start).count();
        //printw("Elapsed: %d\n", elapsed);
    }

    // Clean up all objects previously initialized.

    printw("Cleaning up system. Time to turn off...\n");

    pca9685->setPWM(ESC_FL,0,THROTTLE_OFF);
    pca9685->setPWM(ESC_FR,0,THROTTLE_OFF);
    pca9685->setPWM(ESC_BL,0,THROTTLE_OFF);
    pca9685->setPWM(ESC_BR,0,THROTTLE_OFF);

    pca9685->closePCA9685();
    sleep(1);

    printw("Good bye!\n");
    refresh();
    sleep(3);
    endwin();
}
