// Created by heapr0ll on 7/7/19.
//

#include "Lib/JHPWMPCA9685.h"
#include "Lib/i2c_bno055.h"
#include <ncurses.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <iostream>
#include <ctype.h>
#include <unistd.h>
#include <string.h>
#include <getopt.h>
#include <time.h>
#include <sys/time.h>
#include <chrono>

using namespace std;

// At 50 hz a frame is 20 milliseconds
// The PCA9685 PWM Driver is 12 bits
// Full Reverse signal to the ESC is 1 ms
// Neutral signal to the ESC is 1.5 ms
// Full Throttle signal to the ESC is 2 ms

int THROTTLE_OFF = 1638;
int THROTTLE_MEDIUM = 2457;
int THROTTLE_FULL = 3276;
int HOOVER = 2210; //2195

// Loop time in Micro-Seconds. ~ 12 milli seconds.
int rate = 10000;

// The ESC is plugged into the following PWM channel
int ESC_FL = 0;
int ESC_FR = 1;
int ESC_BL = 2;
int ESC_BR = 3;

// Defining desired pitch roll and yaw angles.
float PITCH = 0;
float ROLL = 0;
float YAW = 0;
float angle_yaw = 0;

// Pitch - PID 
// Roll  - PID
// Yaw   - PI
float pitch_gains[3] = {1.2, 0.01, 42.0};
float roll_gains[3] =  {1.2, 0.01, 42.0};
float yaw_gains[3] =   {24, 0.08, 0.0};

// Variables for controller.
float delta_t = 0.0;
float old_error[3] =   {0.0, 0.0, 0.0};
float total_error[3] = {0.0, 0.0, 0.0};
float new_err[3];
int adjustments[3] = {0,0,0};
int new_speeds[4] = {0, 0, 0, 0};

// Global variables for bno055
opmode_t newmode = ndof_fmc;
char sendaddr[5] = "0x28";
char calfile[21] = "../cal_files/bno.cfg";

// PCA Variables
PCA9685 *pca9685;

bool run = true;

char input;

void catchC(int sig){
    run = false;
}


int main() {

    //  Using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
    //  Or, you can create the .ini in some other directory by using:
    //      RTIMUSettings *settings = new RTIMUSettings("<directory path>", "RTIMULib");
    //  where <directory path> is the path to where the .ini file is to be loaded/saved
    initscr();
    nodelay(stdscr, true);
    scrollok(stdscr, true);
    noecho();
    //raw();

    // Initialize the BNO055.
    // Checking if the sensor is actually connected and on the write address. (If fails program exits)
    get_i2cbus(sendaddr);

    // Loading cal file into bno. (I think this will exit if it doesnt happen correctly.)
    load_cal(calfile);

    // Put bno into fast fusion mode. (Obviously exits if failes lol)
    int res = set_mode(newmode);
    if(res != 0) {
        printw("Error: could not set sensor mode [0x%02X].\n", newmode);
        exit(-1);
    }

    // BNO initialization finished. Ready to start reading it.
    // Going to double check if we are in fusion mode.
    int mode = get_mode();
    if(mode < 8){
        printw("Error - Not in fusion mode, in %d mode.\n", mode);
        exit(-1);
    }

    printw("BNO ready to work!\n");
    delta_t = (float)rate/1000000.0;

    printw("Sampling the imu at: %d\n", rate);

    pca9685 = new PCA9685() ;
    int err = pca9685->openPCA9685();
    if (err < 0){
        printw("Error: %d", pca9685->error);
    }
    printw("PCA9685 Device Address: 0x%02X\n",pca9685->kI2CAddress) ;
    pca9685->setAllPWM(0,0) ;
    pca9685->reset() ;
    pca9685->setPWMFrequency(400) ;

    pca9685->setPWM(ESC_FL,0,THROTTLE_OFF);
    pca9685->setPWM(ESC_FR,0,THROTTLE_OFF);
    pca9685->setPWM(ESC_BL,0,THROTTLE_OFF);
    pca9685->setPWM(ESC_BR,0,THROTTLE_OFF);

    printw("PCA9685 ready to work!\n");
    refresh();

    sleep(5);

    float angles[3];
    signal(SIGINT, catchC);

    while (run) {
        // To make it even more robust timing wise, check system time before if statement,
        // then check system time after if, find out time left until 13 milliseconds have passed,
        // then wait for that amount of time.
        auto start = chrono::steady_clock::now();

        input = getch();
        if (input == '\33'){
            getch();
            input = getch();
            if (input == 'A'){
                HOOVER++;
            }
            if (input == 'B'){
                HOOVER--;
            }
        }else if(input == 'q'){ // ++ 'P' Gains --- PITCH AND ROLL

	    pitch_gains[0] += 1;
	    roll_gains[0] += 1;

	}else if(input == 'w'){ // ++ 'I' Gains

            pitch_gains[1] += .1;
	    roll_gains[1] += .1;

	}else if(input == 'e'){ // ++ 'D' Gains

            pitch_gains[2] += 5;
	    roll_gains[2] += 5;

	}else if(input == 'a'){ // -- 'P' Gains

            pitch_gains[0] -= 1;
	    roll_gains[0] -= 1;

	}else if(input == 's'){ // -- 'I' Gains

            pitch_gains[1] -= .1;
	    roll_gains[1] -= .1;

        }else if(input == 'd'){ // -- 'D' Gains

            pitch_gains[2] += 5;
	    roll_gains[2] += 5;

	}else if(input == 'z'){ // ++ 'P' Gain --- YAW

            yaw_gains[0] += 1;

	}else if(input == 'x'){ // ++ 'I' Gain

	    yaw_gains[1] += .1;
            
	}else if(input == 'c'){ // -- 'P' Gain

            yaw_gains[0] -= 1;
            
	}else if(input == 'v'){ // -- 'I' Gain

	    yaw_gains[1] -= .1;
            
	}

	// Reading the BN0. With Gyro
	struct bnogyr bnod1;
	res = get_gyr(&bnod1);
	if (res != 0){
	    printw("Error: Could not read Gyro angles data .\n");
	    break;
	}

        // Reading the BNO.
        struct bnoeul bnod;
        res = get_eul(&bnod);
        if(res != 0){
            printw("Error: Could not read Euler orientation data.\n");
            break;
        }

        angle_yaw += bnod1.gdata_y*.012;
        // Controller code.
        angles[0] = bnod.eul_pitc;
        angles[1] = bnod.eul_roll;
        angles[2] = angle_yaw;
	//printw("Gyro yaw %f\n", angles[2]);

        new_err[0] = PITCH - angles[0];
        new_err[1] = ROLL - angles[1];
        new_err[2] = YAW - angles[2];
	
	// Calculating Integral
        total_error[0] += pitch_gains[1] * new_err[0];
        total_error[1] += roll_gains[1] * new_err[1];
	total_error[2] += yaw_gains[1] * new_err[2];

        // Actual PID Calculations
	// ----------------------------------------------------------------------------------------------------------
	//                          Proportional              Integral                 Derivative
        adjustments[0] = (int)(pitch_gains[0]*new_err[0] + total_error[0] + pitch_gains[2]*(new_err[0]-old_error[0]) );
        adjustments[1] = (int)(roll_gains[0]*new_err[1]  + total_error[1] + roll_gains[2]*(new_err[1]-old_error[1]) );
        adjustments[2] = (int)(yaw_gains[0]*new_err[2]   + total_error[2]);

        // Update errors such that old becomes new.
        old_error[0] = new_err[0];
        old_error[1] = new_err[1];
        old_error[2] = new_err[2];

        // Keeping Yaw out of this for now lol. It is because yaw works with a magnometer
        // which will most likely require calibration after flying for a few seconds.
        // ----------------------------------------------------------------------------
        //                         PITCH             ROLL             YAW
        new_speeds[0] = HOOVER + adjustments[0] + adjustments[1] + adjustments[2];
        new_speeds[1] = HOOVER + adjustments[0] - adjustments[1] - adjustments[2];
        new_speeds[2] = HOOVER - adjustments[0] + adjustments[1] - adjustments[2];
        new_speeds[3] = HOOVER - adjustments[0] - adjustments[1] + adjustments[2];

	// Limiting output between min and max throttle.
        (new_speeds[0] < THROTTLE_OFF) ?  (new_speeds[0] = THROTTLE_OFF) : new_speeds[0];
        (new_speeds[0] > THROTTLE_FULL) ? (new_speeds[0] = THROTTLE_FULL): new_speeds[0];
        (new_speeds[1] < THROTTLE_OFF) ?  (new_speeds[1] = THROTTLE_OFF) : new_speeds[1];
        (new_speeds[1] > THROTTLE_FULL) ? (new_speeds[1] = THROTTLE_FULL): new_speeds[1];
        (new_speeds[2] < THROTTLE_OFF) ?  (new_speeds[2] = THROTTLE_OFF) : new_speeds[2];
        (new_speeds[2] > THROTTLE_FULL) ? (new_speeds[2] = THROTTLE_FULL): new_speeds[2];
        (new_speeds[3] < THROTTLE_OFF) ?  (new_speeds[3] = THROTTLE_OFF) : new_speeds[3];
        (new_speeds[3] > THROTTLE_FULL) ? (new_speeds[3] = THROTTLE_FULL): new_speeds[3];

        //printw("Values %d, %d, %d, %d\n", new_speeds[0], new_speeds[1], new_speeds[2], new_speeds[3]);

	// Applying new speeds to motors.

        //pca9685->setPWM(ESC_FL,0,new_speeds[0]);
        //pca9685->setPWM(ESC_FR,0,new_speeds[1]);
        //pca9685->setPWM(ESC_BL,0,new_speeds[2]);
        //pca9685->setPWM(ESC_BR,0,new_speeds[3]);

        pca9685->mass_fast_setPWM(ESC_FL, 0, new_speeds, 4);
	//int dat[] = {0,0,0,0};
        //dat[0] = pca9685->readByte(PCA9685_LED0_ON_L);
        //dat[1] = pca9685->readByte(PCA9685_LED0_ON_H);
        //dat[2] = pca9685->readByte(PCA9685_LED0_OFF_L);
        //dat[3] = pca9685->readByte(PCA9685_LED0_OFF_H);

	//printw("Actual data in motor 1 %d, %d, %d, %d\n", dat[0], dat[1], dat[2], dat[3]);

	// Waiting if we still have time in this cycle.
	// If we went over, don't delay, just keep going.
	// Mostly only go over by a couple hundred micro seconds.
        auto end = chrono::steady_clock::now();
        int elapsed = chrono::duration_cast<chrono::microseconds>(end - start).count();
        //printw("Elapsed Time micro-seconds: %d\n", elapsed);
        if ((rate - elapsed) < 0) {
            printw("Oops! Something took to long.\n");
            continue;
        }
        //usleep(rate - elapsed);
        refresh();
        //auto end2 = chrono::steady_clock::now();
        //elapsed = chrono::duration_cast<chrono::microseconds>(end2 - start).count();
        //printw("Elapsed: %d\n", elapsed);
    }

    // Delete up all objects.
    printw("Cleaning up system. Time to turn off...\n");

    pca9685->setPWM(ESC_FL,0,THROTTLE_OFF);
    pca9685->setPWM(ESC_FR,0,THROTTLE_OFF);
    pca9685->setPWM(ESC_BL,0,THROTTLE_OFF);
    pca9685->setPWM(ESC_BR,0,THROTTLE_OFF);

    pca9685->closePCA9685();
    sleep(1);

    printw("Good bye!\n");
    refresh();
    sleep(3);
    endwin();
    
    // Persistent prints.
    printf("Pitch Gains: %f, %f, %f\n", pitch_gains[0], pitch_gains[1], pitch_gains[2]);
    printf("Roll Gains: %f, %f, %f\n",  roll_gains[0],  roll_gains[1],  roll_gains[2]);
    printf("Yaw Gains: %f, %f, %f\n",   yaw_gains[0],   yaw_gains[1],   yaw_gains[2]);
}
